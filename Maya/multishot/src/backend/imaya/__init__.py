# uncompyle6 version 3.2.3
# Python bytecode 2.7 (62211)
# Decompiled from: Python 2.7.15 (v2.7.15:ca079a3ea3, Apr 30 2018, 16:30:26) [MSC v.1500 64 bit (AMD64)]
# Embedded file name: C:/Users/qurban.ali.ICE-144/Documents/maya/scripts\shot_subm\src\backend\imaya\__init__.py
# Compiled at: 2017-11-08 17:37:11
import iMaya
reload(iMaya)

def setConfig(conf):
    iMaya.conf = conf


from iMaya import *
try:
    import pymel.core as pc
except:
    pass

doCreateGeometryCache2 = 'global proc string[] doCreateGeometryCache2 ( int $version, string $args[] )\n//A facsimle copy of doCreateGeometryCache just that args[6] i.e. export cache\n//per geometry is fixed to 1 regardless of group caching\n{\n        string $cacheFiles[];\n        if(( $version > 5 ) || ( size($args) > 16 )) {\n                error( (uiRes("m_doCreateGeometryCache.kBadArgsError")));\n                return $cacheFiles;\n        }\n\n        string  $cacheDirectory         = "";\n        string  $fileName                       = "";\n        int             $useAsPrefix            = 0;\n        int             $perGeometry            = 0;\n        string  $action        = "replace";\n        int     $force = 0;\n        int             $inherit = 0;\n        int     $doubleToFloat = 0;\n        string $distribution = "OneFilePerFrame";\n\n        int     $rangeMode                      = $args[0];\n        float   $diskCacheStartTime = $args[1];\n        float   $diskCacheEndTime   = $args[2];\n        float   $simulationRate         = 1.0;\n        int             $sampleMultiplier       = 1;\n\n        float  $startTime = $diskCacheStartTime;\n        float  $endTime = $diskCacheEndTime;\n        string $format = "mcc";         // Maya\'s default internal format\n\n        if( $rangeMode == 1 ) {\n        $startTime = `getAttr defaultRenderGlobals.startFrame`;\n        $endTime = `getAttr defaultRenderGlobals.endFrame`;\n        } else if( $rangeMode == 2 ) {\n                $startTime = `playbackOptions -q -min`;\n                $endTime = `playbackOptions -q -max`;\n        }\n\n        if ($version > 1) {\n            $distribution = $args[3];\n                $cacheDirectory = $args[5];\n                $perGeometry = $args[6];\n                $fileName = $args[7];\n                $useAsPrefix = $args[8];\n        }\n        if ($version > 2) {\n                $action = $args[9];\n                $force = $args[10];\n\n                if( size($args) > 11 ) {\n                        $simulationRate = $args[11];\n                }\n                if( size($args) > 12 ) {\n                        $sampleMultiplier = $args[12];\n                }\n                else {\n                        $sampleMultiplier = 1;\n                }\n        }\n        if( $version > 3 ) {\n                $inherit = $args[13];\n                $doubleToFloat = $args[14];\n        }\n\n        if( $version > 4 ) {\n                $format = $args[15];\n        }\n\n        // Call doMergeCache instead since it handles gaps between\n        // caches correctly.\n        if( $action == "merge" || $action == "mergeDelete" )\n        {\n\n                string $mergeArgs[];\n                $mergeArgs[0] = 1;\n                $mergeArgs[1] = $startTime;\n                $mergeArgs[2] = $endTime;\n                $mergeArgs[3] = $args[3];\n                $mergeArgs[4] = $cacheDirectory;\n                $mergeArgs[5] = $fileName;\n                $mergeArgs[6] = $useAsPrefix;\n                $mergeArgs[7] = $force;\n                $mergeArgs[8] = $simulationRate;\n                $mergeArgs[9] = $sampleMultiplier;\n                $mergeArgs[10] = $action;\n                $mergeArgs[11] = "geom";\n                $mergeArgs[12] = $format;\n                return doMergeCache(2, $mergeArgs);\n        }\n\n        // If we\'re replacing a cache, and inheriting modifications,\n        // the new cache should have the same translation, scaling\n        // and clipping as the original. So store these values and\n        // set after cache creation.\n        //\n        float $startFrame[] = {};\n        float $sourceStart[] = {};\n        float $sourceEnd[] = {};\n        float $scale[] = {};\n\n        select -d `ls -sl -type cacheFile`;\n        string $objsToCache[] = getGeometriesToCache();\n        if (size($objsToCache) == 0) {\n                error((uiRes("m_doCreateGeometryCache.kMustSelectGeom")));\n        } else  if ($action == "replace") {\n                if (!getCacheCanBeReplaced($objsToCache)) {\n                        return $cacheFiles;\n                }\n\n                if( $inherit ) {\n                        string $obj, $cache;\n                        for( $obj in $objsToCache ) {\n                                string $existing[] = findExistingCaches($obj);\n                                int $index = size($startFrame);\n                                $startFrame[$index] = `getAttr ($existing[0]+".startFrame")`;\n                                $sourceStart[$index] = `getAttr ($existing[0]+".sourceStart")`;\n                                $sourceEnd[$index] = `getAttr ($existing[0]+".sourceEnd")`;\n                                $scale[$index] = `getAttr ($existing[0]+".scale")`;\n                        }\n                }\n        }\n\n        // If the user has existing cache groups on some of the geometry,\n        // then they cannot attach new caches per geometry.\n        //\n    string $cacheGroups[] = `getObjectsByCacheGroup($objsToCache)`;\n        if (size($cacheGroups) != size($objsToCache)) {\n                $perGeometry = 1;\n                $args[6] = 1; // used below in generating cache file command\n                //warning( (uiRes("m_doCreateGeometryCache.kIgnoringPerGeometry")) );\n        }\n\n        // Check if directory has caches that might be overwritten\n        //\n        string $cacheDirectory = getCacheDirectory(     $cacheDirectory, "fileCache",\n                                                                                                $objsToCache, $fileName,\n                                                                                                $useAsPrefix, $perGeometry,\n                                                                                                $action, $force, 1);\n\n        if ($cacheDirectory == "") {\n                return $cacheFiles;\n        }\n        else if ($cacheDirectory == "rename") {\n                performCreateGeometryCache 1 $action;\n                error((uiRes("m_doCreateGeometryCache.kNameAlreadyInUse")));\n                return $cacheFiles;\n        }\n\n        // if we\'re replacing, delete active caches.\n        //\n        if( $action == "replace" ) {\n                for( $obj in $objsToCache ) {\n                        string $all[] = findExistingCaches($obj);\n                        for( $cache in $all) {\n                                if( `getAttr ($cache+".enable")`) {\n                                        deleteCacheFile(2, {"keep",$cache});\n                                }\n                        }\n                }\n        }\n\n        // create the cache(s)\n        //\n        if ($action == "add" || $action == "replace") {\n                setCacheEnable(0, 1, $objsToCache);\n        }\n\n        // generate the cacheFile command to write the caches\n        //\n        string $cacheCmd = getCacheFileCmd($version, $cacheDirectory, $args);\n        int $ii = 0;\n\n        //segmented cache files are employed in the case of one large cache file that\n        //exceeds 2GB in size.  Since we currently cannot handle such large files, we will\n        //automatically generate several caches, each less than 2GB.\n        int $useSegmentedCacheFile = 0;\n        int $numSegments = 0;\n        if($distribution == "OneFile" && !$perGeometry) {\n            string $queryCacheSizeCmd = "cacheFile";\n            for ($ii = 0; $ii < size($objsToCache); $ii++) {\n                    $queryCacheSizeCmd += (" -points "+$objsToCache[$ii]);\n            }\n            $queryCacheSizeCmd += " -q -dataSize";\n            if($doubleToFloat) {\n                $queryCacheSizeCmd += " -dtf";\n            }\n            float $dataSizePerFrame = `eval $queryCacheSizeCmd`;\n            float $maxSize = 2147000000; //approximate size of max signed int.\n            float $numSamples = ($endTime - $startTime + 1.0)/($simulationRate*$sampleMultiplier);\n            float $dataSize = $dataSizePerFrame*$numSamples;\n            if($dataSize > $maxSize) {\n                $useSegmentedCacheFile = 1;\n                $numSegments = floor($dataSize / $maxSize) + 1;\n            }\n        }\n\n        if(!$useSegmentedCacheFile) {\n            if( $fileName != "" ) {\n                    $cacheCmd += ("-fileName \\"" + $fileName + "\\" ");\n            }\n            $cacheCmd += ("-st "+$startTime+" -et "+$endTime);\n            for ($ii = 0; $ii < size($objsToCache); $ii++) {\n                    $cacheCmd += (" -points "+$objsToCache[$ii]);\n            }\n            $cacheFiles = `eval $cacheCmd`;\n        }\n        else {\n            int $jj;\n            float $segmentStartTime = $startTime;\n            float $segmentEndTime;\n            float $segmentLength = ($endTime - $startTime)/$numSegments;\n            string $segmentCacheCmd ;\n            string $segmentCacheName = "";\n            string $segmentCacheFiles[];\n            for($jj = 0; $jj< $numSegments; $jj++) {\n                $segmentCacheCmd = $cacheCmd;\n                if($fileName != "")\n                    $segmentCacheName = $fileName;\n                else\n                    $segmentCacheName = getAutomaticCacheName();\n                $segmentEndTime = $segmentStartTime + floor($segmentLength);\n\n                $segmentCacheName += ("Segment" + ($jj+1));\n                $segmentCacheCmd += (" -fileName \\"" + $segmentCacheName + "\\" ");\n\n                $segmentCacheCmd += ("-st "+$segmentStartTime+" -et "+$segmentEndTime);\n                for ($ii = 0; $ii < size($objsToCache); $ii++) {\n                        $segmentCacheCmd += (" -points "+$objsToCache[$ii]);\n                }\n                $segmentCacheFiles = `eval $segmentCacheCmd`;\n                $segmentStartTime = $segmentEndTime + 1;\n\n                $cacheFiles[size($cacheFiles)] = $segmentCacheFiles[0];\n            }\n    }\n\n        if ($action == "export") {\n                for ($ii = 0; $ii < size($cacheFiles); $ii++) {\n                        $cacheFiles[$ii] = ($cacheDirectory+"/"+$cacheFiles[$ii]+".xml");\n                }\n                // In export mode, we do not want to attach the cache. We are done.\n                //\n                return $cacheFiles;\n        }\n\n\n        // attach the caches to the history switch\n        //\n        if($useSegmentedCacheFile) {\n            if(size($objsToCache) == 1) {\n                for($ii=0;$ii<size($cacheFiles);$ii++) {\n                    string $segmentCacheFile[];\n                    $segmentCacheFile[0] = $cacheFiles[$ii];\n                    attachOneCachePerGeometry(  $segmentCacheFile, $objsToCache,\n                                                                        $cacheDirectory, $action, $format );\n                }\n            }\n            else {\n                for($ii=0;$ii<size($cacheFiles);$ii++) {\n                    string $segmentCacheFile[];\n                    $segmentCacheFile[0] = $cacheFiles[$ii];\n                    attachCacheGroups( $segmentCacheFile,$objsToCache,$cacheDirectory,$action, $format );\n                }\n            }\n\n        }\n        else if( $perGeometry || size($objsToCache) == 1) {\n                attachOneCachePerGeometry(      $cacheFiles, $objsToCache,\n                                                                        $cacheDirectory, $action, $format );\n        } else {\n                if( size($cacheFiles) != 1 ) {\n                        error( (uiRes("m_doCreateGeometryCache.kInvalidCacheOptions")));\n                }\n\n                attachCacheGroups( $cacheFiles,$objsToCache,$cacheDirectory,$action, $format );\n\n        }\n\n        // If we\'re replacing a cache and inheriting modifications,\n        // restore the translation, scaling, clipping etc.\n        if( $action == "replace" && $inherit )\n        {\n                int $i = 0;\n                for( $i = 0; $i < size($objsToCache); $i++)\n                {\n                        string $cache[] = findExistingCaches($objsToCache[$i]);\n                        float $sStart = `getAttr ($cache[0]+".sourceStart")`;\n                        float $sEnd = `getAttr ($cache[0]+".sourceEnd")`;\n\n                        if( $sStart != $sourceStart[$i] &&\n                                $sourceStart[$i] >= $sStart &&\n                                $sourceStart[$i] <= $sEnd )\n                        {\n                                cacheClipTrimBefore( $cache[0], $sourceStart[$i] );\n                        }\n\n                        if( $sEnd != $sourceEnd[$i] &&\n                                $sourceEnd[$i] >= $sStart &&\n                                $sourceEnd[$i] <= $sEnd )\n                        {\n                                cacheClipTrimAfter( $cache[0], $sourceEnd[$i] );\n                        }\n\n                        setAttr ($cache[0] + ".startFrame") $startFrame[$i];\n                        setAttr ($cache[0] + ".scale") $scale[$i];\n                }\n        }\n        select -r $objsToCache;\n        return $cacheFiles;\n};'
try:
    pc.Mel.eval(doCreateGeometryCache2)
except:
    pass
# okay decompiling __init__.pyc
